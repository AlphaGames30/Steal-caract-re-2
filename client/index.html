<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Steal-a-Thing 3D</title>
<style>
  body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
  #info { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 6px; }
</style>
</head>
<body>
<div id="info">
  <h1>Steal-a-Thing 3D üöÄ</h1>
  <p>8 bases √ó 12 slots. Personnages al√©atoires.</p>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js';

// --- Sc√®ne ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);

// --- Cam√©ra ---
const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 25, 40);
camera.lookAt(0, 0, 0);

// --- Renderer ---
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Lumi√®res ---
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(10, 20, 10);
scene.add(directionalLight);

// --- Tapis blanc ---
const tapisGeometry = new THREE.PlaneGeometry(40, 30);
const tapisMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
const tapis = new THREE.Mesh(tapisGeometry, tapisMaterial);
tapis.rotation.x = -Math.PI / 2;
scene.add(tapis);

// --- Bases et slots ---
const BASES = 8;
const SLOTS = 12;
const baseWidth = 4;
const baseDepth = 2;
const slotSpacing = 1;

const characters = [
  { name: "Petit Titan", color: 0xff0000 },
  { name: "Souris Malicieuse", color: 0x00ff00 },
  { name: "Mini Robot", color: 0x0000ff }
];

for (let b = 0; b < BASES; b++) {
  for (let s = 0; s < SLOTS; s++) {
    // Cr√©e un cube pour le slot
    const slotGeometry = new THREE.BoxGeometry(baseWidth, 1, baseDepth);
    const slotMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd });
    const slot = new THREE.Mesh(slotGeometry, slotMaterial);

    slot.position.x = (s - SLOTS/2) * (baseWidth + slotSpacing) + baseWidth/2;
    slot.position.z = (b - BASES/2) * (baseDepth + slotSpacing) + baseDepth/2;
    slot.position.y = 0.5;

    // Ajouter personnage al√©atoire selon chance
    const rand = Math.random();
    if (rand < 0.3) { // 30% de chance
      const char = characters[Math.floor(Math.random() * characters.length)];
      const charGeom = new THREE.BoxGeometry(1, 2, 1);
      const charMat = new THREE.MeshStandardMaterial({ color: char.color });
      const charMesh = new THREE.Mesh(charGeom, charMat);
      charMesh.position.y = 1.5; // au-dessus du slot
      charMesh.position.x = slot.position.x;
      charMesh.position.z = slot.position.z;
      scene.add(charMesh);
    }

    scene.add(slot);
  }
}

// --- Animation ---
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

animate();

// --- Gestion du redimensionnement ---
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
